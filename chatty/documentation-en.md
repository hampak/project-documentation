# Table of Contents
1. [Project Overview](#project-overview)
2. [API Documentation](#api-documentation)
3. [Web Socket Documentation](#web-socket-documentation)
4. Features
5. Notable Bugs & Problems I encountered
6. Learning Experience

# Project Overview
Chatty is a chatting application where users can communicate with each other. The idea of real-time communication has always intrigued me and I was really interested in building a project like this. I learned a lot of technologies while building this project such as **redis** and **web sockets**.

I built this project using the tech stack / packages below:
```json
{
  "express",
  "mongoose",
  "socket.io",
  "jsonwebtoken",
  "redis",
  "google-auth-library",
  "cookie",
  "react",
  "@tanstack/react-query",
  "react-hook-form",
  "react-router-dom",
  "tailwind",
  "zod",
  "zustand"
}
```

I chose **ExpressJS** because I wanted to be more comfortable using it. For the main database, I used **MongoDB** and for data requiring a lot of read/writes, I used **redis(upstash)**.

One important thing to note here is that I didn't use an authentication service such as Clerk or Kinde. I wanted to learn **OAuth 2.0** so I didn't use any of those third-party authentication service providers.

In the frontend, I used **React**. For routing and navigation I used **react router dom**. For data fetching, I used **tanstack query**. For styling I used **tailwindcss**.

The server is deployed on **railway** and the client is hosted on **vercel**.

Through this project, I wanted to fortify my knowledge on key concepts of some of the most important technologies used around the world.

# API Documentation
- [`/api/auth`](#apiauth)
- [`/api/user`](#apiuser)
- [`/api/friend`](#apifriend)
- [`/api/chat`](#apichat)

### `/api/auth`
- [`api/auth/google`](#apiauthgoogle)
- [`api/auth/google/callback`](#apiauthgooglecallback)
- [`api/auth/github`](#apiauthgithub)
- [`api/auth/github/callback`](#apiauthgithubcallback)
- [`api/auth/logout`](#apiauthlogout)
- [`api/auth/check-auth`](#apiauthcheck-auth)

#### `/api/auth/google`
**Method**: GET

Api route that gets called when the user clicks on "Start with Google". When this api route gets called, it uses the **google-auth-library** package to create a **redirect url**.

```ts
const authUrl = oauth2Client.generateAuthUrl({
  access_type: "offline",
  scope: 'https://www.googleapis.com/auth/userinfo.profile  openid ',
  prompt: "consent"
})
```

The user is then redirected to the **authUrl** page. In this page, the user selects which Google account they will use to access Chatty.

This route also implements a check where it takes a look at the cookie in the user's web browser. When it retrieves a cookie named **user**, the route will check in the database to see if the decoded token (using JWT) is valid. If it is not valid (say, the user put invalid cookie data), they will get redirected to the **authUrl** page. If the decoded cookie value does turn out to be valid, the user will be redirected to the **/dashboard** page in the client rather than the **authURL** page.

```ts title="/api/auth/google"
const token = req.cookies.user

if (token) {
  try {
    const decoded = jwt.verify(token, JWT_SCRET!)
    if (typeof decoded !== "string" && decoded.user._id) {
      User.findById(decoded.user_id).then(user => {
        if (user) {
          return res.redirect(`${CLIENT_URL}/dashboard`)
        } else {
          // generate authURL and redirect user to the Google login page
        }
      })
    }
  } catch (error) {
    // if any error happens, generate authURL and redirect the user to the Google login page
  }
} else {
  // generate authURL and redirect the user to the Google login page
}
```

#### `/api/auth/google/callback`
**Method**: GET

After the user gets redirected to the Google account select page, and after the user chooses an account, this api route is called. In this api route, I implemented logic to retrieve the user's token which in turn can be used to access user information such as **sub** (An identifier for the user, unique among all Google accounts and never changed.), **name** and **picture**.

One of the most important logic in this api route is checking to see if the user already exists in our database. This is implemented by simply checking if a user with a **google_id** - which was provided by Google - already exists. If this is the case, carry on with the rest of the logic. If it's not the case (the user's first time accessing this application), save the user in our database.

The logged in user's data is stored as a cookie which is named **user** with a value generated by JWT.

```ts
const token = jwt.sign({
  user_id,
  name,
  picture
},
  JWT_SECRET!,
  { expiresIn: "60m" }
)

res.cookie("user", token, {
  httpOnly: true,
  maxAge: 60 * 60 * 1000,
  // other configurations
})

res.redirect(`${CLIENT_URL}/dashboard`)
```

#### `/api/auth/github`
**Method**: GET

This api route handles users who want to log in with their Github account. When the user clicks on "Start with Github", the client is directed to this route. Here, we retrieve the github redirect URL.

```ts
.get("/github", async (req, res) => {
  const redirectUrl = `https://github.com/login/oauth/authorize?client_id=${GITHUB_CLIENT_ID}&redirect_uri=http://localhost:8000/api/auth/github/callback&scope=user`

  res.redirect(redirectUrl)
})
```

#### `/api/auth/github/callback`
**Method**: GET

This route is for those redirected from the `/api/auth/github` route. It retrieves the access token using the **GITHUB_CLIENT_ID** and **GITHUB_CLIENT_SECRET**. From this, we can get the user's Github account information such as the **profile picture**, **name** and **id**. The **id** will be used as a unique identifier when we store the user in MongoDB database.

```ts
const { code } = req.query;

if (!code) {
  return res.status(400).send("No code provided")
}

try {
  const tokenResponse = await axios.post(
    "https://github.com/login/oauth/access_token",
    {
      client_id: GITHUB_CLIENT_ID,
      client_secret: GITHUB_CLIENT_SECRET,
      code
    },
    {
      headers: {
        accept: "application/json"
      }
    }
  )

  const accessToken = tokenResponse.data.access_token

  const userResponse = await axios.get("https://api.github.com/user", {
    headers: {
      Authorization: `Bearer ${accessToken}`
    }
  })

  const { avatar_url, name, id } = userResponse.data
  ...
  } catch ...
```

After this, the logic is pretty much the same with the `/api/auth/google/callback` route.

#### `/api/auth/logout`
**Method**: GET

This route logs the client out of the application. It clears the cookie (which holds the session token) from the user's browser and also deletes the session token from our redis database. The user is then navigated to the dashboard page.

```ts
.get("/logout", async (req, res) => {
    const token = await req.cookies.user
    const decoded = jwt.verify(token, JWT_SECRET!) as JwtPayload

    res.clearCookie("user")
    await redis.del(`sessionToken-${decoded.user_id}`)
    res.redirect(`${CLIENT_URL}`)
  })
```

#### `/api/auth/check-auth`
**Method**: GET

This route is used for **route protection** in our client. It first checks if a cookies of the name "user" exists. If it doesn't, send a **401** error which will redirect the user to the `/login` page.

If there is a token, run some checks to see if it also exists in the database. Send a **200** status if the user is authenticated. Send a **401** status if the user is not (which will send the user back to the login page.

This route is used [here]()

### `/api/user`
- [`/api/user`](#apiuser)

#### `/api/user`
**Method**: GET

This api route is used to retrieve the information of the currently logged in user. It checks the session token to see if it's valid. After that, the route queries the MongoDB database and retrieves the following information:

- id - the unique user id generated by MongoDB
- name - the name of the user (name set in Google / Github depending on registration method)
- picture - the profile image of the user
- online - the online status of the user (**This value isn't used as I'm retrieving the online status from Redis**)
- userTag - a unique identifier **used by the users** to add each other as friends

Just as a safety measure, if there's anything wrong with the token, the server sends a **401** error.

### `/api/friend`
- [`/api/friend`](#apifriend)
- [`/api/friend/add-friend`](#apifriendadd-friend)
- `/api/friend/delete-friend` **Not built yet**

#### `/api/friend`
**Method**: GET

This route fetches the friend(s) of the currently logged in user. It receives the **userId** from the client and queries the database. If there isn't a user with the id of **userId** found, return a **401** error.

If there is, query the user's friend(s) and their data

- _id - the unique user id generated by MongoDB
- name - name of the friend
- image - profile image of the friend
- userTag - userTag of the friend

This data is then stored in a array called **friends** which is then sent to the client.

```ts
const friendsList = await User.find({
  _id: { $in: user.friends }
}).select("_id name image userTag")

const friends = friendsList.map(friend => ({
  userId: friend._id.toString(),
  name: friend.name,
  image: friend.image,
  userTag: friend.userTag
}))
```

#### `/api/friend/add-friend`
**Method**: POST

This route adds a friend for the user. It receives the **friendUserTag** and **userId** from the client. The api first checks to see if the user is already friends with the current user. If they are already friends, send an error message to the client. Also, check to see if the user is trying to befriend him/herself (as this shouldn't be possible).

After these checks, add the friend's id to the list of the current user's friends in the database. Do it the same vice versa as the friend's friend list should also be updated.

We also update the friends list on redis. We do this so we can quickly read/write in our socket server.

After the friend has been successfully added, send back the following data to the client:

- friendUserTag - the userTag of the added friend
- friendName - the name of the added friend
- friendId - the id of the added friend

### `/api/chat`
- [`/api/chat/chat-list`](#apichatchat-list)
- [`/api/chat/create-chat`](#apichatcreate-chat)
- [`/api/chat/chat-info`](#apichatchat-info)

#### `api/chat/chat-list`
**Method**: GET

This api route retrieves the list of chats the currently logged in user is participating in. After checking if the **userId** is valid, the api route fetches from the database.

```ts
const data = await ChatRoom.find({
  participants: { $elemMatch: { participantId: userId } }
})
```

This data is then mapped over. It returns an array of data called **chatRooms** which will be sent to the client.

The main logic happens within this `.map()`. First, we retrieve the last message which will be shown in the current user's UI. We do this by querying redis and getting the most recent message.

```ts
const lastMessageRaw = await redis.zrange(`messages-${room._id}`, -1, -1)
lastMessage = lastMessageRaw[0] ? JSON.parse(lastMessageRaw[0]) : ""
```

After this, the names of the participants are extracted. Note that the current user's name isn't sent to the client.

```ts
const allParticipants = room.room_title.split("|").map(p => p.trim())
const friendName = allParticipants.find(p => p !== name)
```

Then, we retrieve the "last seen" value of the chatroom. This is done by getting the value from redis.

```ts
const lastSeenTimestamp = await redis.get(`last_seen-${userId}-${chatRoomId}`)
```

The code checks to see if the **lastSeenTimestamp** value exists. If it doesn't, it means that the user has never visited the chatroom. This could be a case where the current user was not logged in Chatty when his/her friends added him/her and started sending messages. If this is the case, we set the **unreadMessagesCount** to the length of the messages of that chatroom (from the very first message to the very last one).

```ts
let unreadMessagesCount = 0;

if (!lastSeenTimestamp) {
  const allMessages = await redis.zrange(`messages-${chatRoomId}`, 0, -1);
  const unreadMessages = allMessages.filter(message => {
    const parsedMessage = JSON.parse(message)
    return parsedMessage.senderId !== currentUserId
  })
  unreadMessagesCount = unreadMessages.length;
} else ...
```

While extracting the **unreadMessagesCount** value, we exclude the messages that was sent by the current user. Although this may not be needed (as the current user has never visited the chatroom - which means that the current user has never sent a message), I just added the check to be safe.

If there is a **lastSeenTimestamp**, it means that the current user has visited this chatroom. In this case, we retrieve the messages that have been sent **after the current user last saw the messages in this room**. Because the messages are stored in a sorted set **with the score being the timestamp when said message was sent**, this is easily possible by doing this:

```ts
else {
  // we retrieve the messages after the user last visited this chatroom
  const messagesAfterLastSeen = await redis.zrangebyscore(`messages-${chatRoomId}`, lastSeenTimestamp, "+inf")
  const unreadMessages = messagesAfterLastSeen.filter(message => {
    const parsedMessage = JSON.parse(message);
    return parsedMessage.senderId !== currentUserId
  })
  unreadMessagesCount = unreadMessages.length
}
```

After all this, we send these values to the client:

- id - the unique id of the chatroom (generated by MongoDB)
- createdAt - the date/time the chatroom was created
- title - the "name" of the chatroom. **friendName** is used here so that the chatroom name is the names of the participants
- participants - this is an array of objects that contain the data of the participants. It includes the unique id and the profile image
- lastMessage - this is the last message that will be displayed in the client's UI
- unreadMessagesCount - this is the number of messages that the current user didn't see

#### `api/chat/create-chat`
**Method**: POST

This api route creates a chat. The server receives data of the current user's friend(s) and creates a chatroom.

The code does some simple checks to see if the request is being sent without any friends selected. The code then checks to see if the current user is trying to create a 1 on 1 chat or a chatroom with more than 2 users. If it's the first case, we do a check to see if the chatroom already exists (if there's already a chatroom consisting of the current user & the friend).

```ts
const chatroomAlreadyExists = await ChatRoom.findOne({
  participants: {
    $all: [
      { $elemMatch: { participantId: friendData[0].friendId } },
      { $elemMatch: { participantId: currentUserId } }
    ]
  },
  $expr: { $eq: [{ $size: "$participants" }, 2] }
})

if (chatroomAlreadyExists) {
  return res.redirect(`CLIENT_URL/dashboard/chat/${chatroomAlreadyExists._id}`)
}

const chatRoom = new ChatRoom({
  room_title: `${currentUserName}, ${friendData[0].friendName}`,
  participants: [
    { participantId: currentUserId, participantPicture: currentUserPicture },
    { participantId: friendData[0].friendId, participantPicture: friendData[0].friendPicture }
  ]
})

await chatRoom.save()
```

If the current user is trying to create a group chat, we don't check if a group chat consisting of the same users exists. This is an exception that I made where a user can create another group chat consisting of the same users.

```ts
const userNames = friendData.map((friend: Friend) => friend.friendName)
const roomTitle = `${currentUserName}, ${userNames.join(", ")}`

const participants = [
  { participantId: currentUserId, participantPicture: currentUserPicture },
  ...friendData.map((friend: Friend) => ({
    participantId: friend.friendId,
    participantPicture: friend.friendPicture
  }))
]

const chatRoom = new ChatRoom({
  room_title: roomTitle,
  participants: participants,
})

await chatRoom.save()
```

#### `api/chat/chat-info`
**Method**: GET

This api route retrieves the data vital for the chatroom including the actual messages sent by users. When a user clicks on a chatroom in the client, the user is navigated to the chatroom page, triggering this route.

Just to make sure that the user isn't trying to access a chatroom he/she isn't part of, I added this code:

```ts
const isParticipant = chatRoomInfo.participants.some(participant =>
  participant.participantId.toString() === user._id.toString()
)

if (!isParticipant) {
  return res.status(403).json({
    message: "You're not part of this chat :("
  })
}
```

The messages are queried from redis and stored in an array **messages**.

```ts
const rawMessages = await redis.zrange(`messages-${chatId}`, 0, -1, "WITHSCORES")
const messages = []
for (let i = 0; i < rawMessages.length; i += 2) {
  const messageJson = rawMessages[i]
  const timestamp = rawMessages[i + 1]
  if (messageJson && timestamp) {
    const message = JSON.parse(messageJson!)
    message.timeStamp = parseInt(timestamp!, 10)
    messages.push(message)
  }
}
```

The most important data sent to the client is the messages.

- messages - the messages. Each message is an object with the actual message, the sender's id, the send timestamp, and the sender's profile image.

# Web Socket Documentation
Real-time functionality is vital for a chatting application. Here is a list of socket events emitted/received by the server/client.

- [`emit("userOnline")`](#emituseronline)
- [`on("userOnline")`](#onuseronline)
- [`emit("retrieveCurrentUser")`](#emitretrieveCurrentUser)
- [`on("retrieveCurrentUser")`](#onretrieveCurrentUser)
- [`emit("getOnlineFriend")`](#emitgetOnlineFriend)
- [`on("getOnlineFriend")`](#ongetOnlineFriend)
- [`emit("retrieveOnlineFriends")`](#emitretrieveOnlineFriends)
- [`on("retrieveOnlineFriends")`](#onretrieveOnlineFriends)
- [`emit("changeStatus")`](#emitchangeStatus)
- [`on("changeStatus")`](#onchangeStatus)
- [`emit("addFriend")`](#emitaddFriend)
- [`on("addFriend")`](#onaddFriend)
- [`emit("addedAsFriend")`](#emitaddedAsFriend)
- [`on("addedAsFriend")`](#onaddedAsFriend)
- [`emit("addedInChatroom")`](#emitaddedInChatroom)
- [`on("addedInChatroom")`](#onaddedInChatroom)
- [`emit("connectToRoom")`](#emitconnectToRoom)
- [`on("connectToRoom")`](#onconnectToRoom)
- [`emit("joinedChatroom")`](#emitjoinedChatroom)
- [`on("joinedChatroom")`](#onjoinedChatroom)



#### `emit("userOnline")`
**Where**: Client

When the user logs in or refreshes the page from the client, this event is emitted to the server with the currently logged in user's id.

```ts
socket.emit("userOnline", user.id)
```

#### `on("userOnline")`
**Where**: Server

When the user logs in to the client, the socket server receives the event which contains the user's id. This is one of the most important code in Chatty. Because users can see their friend's online status (online | away | online), the logic here was important.

We first retrieve the current user's status from redis.

```ts
const status = await redis.hget(`user:${userId}`, "status")
```

We then check if the user's status is either "online" || null or if it's "away". If it's the former case, we set the user's status to "online" just to be sure about the case if the status is "null".

After that, the code retrieves the list of friends of the current user. If there are no friends, the socket server sends the online status of **only the current user** which will be displayed on the user's UI.

```ts
const friends: string[] = await redis.smembers(`friends-${userId}`)

const currentUserStatus = "online"

if (friends.length === 0) {
  return io.to(socket.id).emit("retrieveCurrentUser", socket.id, currentUserStatus)
}
```

If the user has more than one friend, we send that friend the status of the current user. The current users' status will be added or changed in the friend's client state.

```ts
const friendsSocketIdsPromise: Promise<string | null>[] = friends.map(async (friendId) => {
  return await redis.hget(`user:${friendId}`, "socketId")
})

const friendDataPromises = friends.map(friendId => {
  return new Promise<[string | null, string | null]>((resolve) => {
    redis.hmget(`user:${friendId}`, "socketId", "status", (err, values) => {
      resolve(values as [string | null, string | null]);
    })
  })
})

const friendData: [string | null, string | null][] = await Promise.all(friendDataPromises)
const friendSocketId: (string | null)[] = await Promise.all(friendsSocketIdsPromise)

const filteredOnlineFriends: Record<string, { status: string | null; socketId: string | null }> = friendData.reduce((result, [socketId, status], index) => {
  const friendId = friends[index]
  if (status && friendId) {
    result[friendId] = { status, socketId };
  }
  return result
}, {} as Record<string, { status: string | null; socketId: string | null }>);

io.to(socket.id).emit("retrieveOnlineFriends", filteredOnlineFriends)

const validFriendSocketIds = friendSocketId.filter(id => id !== null && id !== undefined);

return validFriendSocketIds.forEach(async id => {
  // send the current user's id + socket id to his/her friends. The client will append / change this value and track it in a state
  io.to(id).emit("getOnlineFriend", currentUserId, socket.id, status)
})
```

We extract the socket ids of the current user's friend along with the friend's online status data. The data is emitted to the current user via the `retrieveOnlineFriends` event to the client. After that, the current user's online status gets emitted to the friend(s).

The logic is identical when the status is **away** for the current user.

#### `emit("retrieveCurrentUser")`
**Where**: Server

This is a simple event containing the current online status of the current user.

```ts
io.to(socket.id).emit("retrieveCurrentUser", socket.id, currentUserStatus)
```

#### `on("retrieveCurrentUser")`
**Where**: Client

When the client receives the **retrieveCurrentUser** event from the server, it sets the user's current online status and the user's socket id in a state.

```ts
socket.on("retrieveCurrentUser", async (currentUserSocketId: string, currentUserStatus: "online" | "away") => {
  setCurrentStatus({
    socketId: currentUserSocketId,
    status: currentUserStatus
  })
})
```

#### `emit("getOnlineFriend")`
**Where**: Server

This event is emitted from the server. It's one of the most important socket events in this application as it sends the current user's online status to the friends. After querying the socket ids of the current user's friend, we map that array and send the friends with relevant data.

```ts
return validFriendSocketIds.forEach(async id => {
  // send the current user's id + socket id to his/her friends. The client will append / change this value and track it in a state
  io.to(id).emit("getOnlineFriend", currentUserId, socket.id, status)
})
```

**A more detailed explanation of the entire code flow is stated [above](#onuseronline)**

#### `on("getOnlineFriend")`
**Where**: Client

When the client receives the **getOnlineFriend** event from the server, the friend's data is stored/updated in the client's state. If the friend's data doesn't exist in the state, it's added. If the friend's data already exists, it's updated.

> **Note that this event is triggered after the user is logged in. When the user refreshes the page or logs in, the server sends the most up-to-date data on the friend's online status. However, for anything that's changed AFTER the user connects, **getOnlineFriend** is triggered. When the user refreshes or logs in, the [retrieveOnlineFriends](#emitretrieveonlinefriends) is triggered**.

```ts
socket.on("getOnlineFriend", async (updatedFriendId: string, updatedFriendSocketId: string, updatedFriendStatus: "online" | "away") => {

  setOnlineFriends(prevOnlineFriends => {
    return {
      ...prevOnlineFriends,
      [updatedFriendId]: {
        status: updatedFriendStatus,
        socketId: updatedFriendSocketId
      }
    }
  })
})
```

#### `emit("retrieveOnlineFriends")`
**Where**: Server

When the user refreshes the client or logs in, this event is sent from the server to the client. It holds the most up-to-date data (on the friend's online status), which is sent to the current user.

This is only emitted when the user has more than one friend.

```ts
const filteredOnlineFriends: Record<string, { status: string | null; socketId: string | null }> = friendData.reduce((result, [socketId, status], index) => {
  const friendId = friends[index]
  if (status && friendId) {
    result[friendId] = { status, socketId };
  }
  return result
}, {} as Record<string, { status: string | null; socketId: string | null }>);

io.to(socket.id).emit("retrieveOnlineFriends", filteredOnlineFriends)
```

#### `on("retrieveOnlineFriends")`
**Where**: Client

When the user logs in or refreshes the client (and has more than 1 friend), this event is emitted from the server. The client stores this data in the state.

> Any status changes happening AFTER the user logs in / refreshes triggers the [getOnlineFriend](#emitgetonlinefriend) event and not this one!

```ts
socket.on("retrieveOnlineFriends", async (data) => {
  setOnlineFriends(data)
})
```

#### `emit("changeStatus")`
**Where**: Client

When the user changes his/her status in the client, this event is triggered from the client. It contains the the user's id and the status (which is either "online" or "away").

```ts
const onSubmit = async (values: { status: "online" | "away" }) => {
    setIsLoading(true)
    socket.emit("changeStatus", values.status, user?.id)
    setTimeout(() => {
      setOpen(false)
      setIsLoading(false)
    }, 1000)
  }
```

#### `on("changeStatus")`
**Where**: Server

When the **changeStatus** is sent from the client, this event is received from the server. This event has important logic in it where it sends the current user his/her updated status. It also sends the friends the updated online status of the user.

The code updates the user's status in redis. Checks to see if the user has friends or not. If the user doesn't have any friends, it only sends the current user's updated status to the client.

```ts
await redis.hset(`user:${userId}`, "status", status)

const friends: string[] = await redis.smembers(`friends-${userId}`)

if (friends.length === 0) {
  return io.to(socket.id).emit("retrieveCurrentUser", socket.id, status)
}
```

The rest of the logic is similar to what we did above. We get the socket ids of the friends, map them over and send the updated online status of the current user.

```ts
const friendsSocketIdsPromise: Promise<string | null>[] = friends.map(async (friendId) => {
  return await redis.hget(`user:${friendId}`, "socketId")
})

const friendSocketId: (string | null)[] = await Promise.all(friendsSocketIdsPromise)

const validSocketIds = friendSocketId.filter(id => id !== null && id !== undefined);

validSocketIds.push(socket.id)

validSocketIds.forEach(id => {
  io.to(id).emit("getOnlineFriend", currentUserId, socket.id, status)
})
```

#### `emit("addFriend")`
**Where**: Client

When a user adds a friend, this event is emitted to the server. THe main purpose of this event is to update the friend's friend list. When the friend receives this event, the query is invalidated.

```ts
socket.emit("addFriend", data.friendId, user?.id, currentStatus?.socketId, currentStatus?.status)
```

#### `on("addFriend")`
**Where**: Server

When emitted from the client, we retrieve the friend's online status and socket id values from redis. We then check if the user has a socket id. If one doesn't exist, it means that the friend isn't online where we don't have to invalidate the query for the friend. However, if that's not the case, we **emit** the **getOnlineFriend** to the current user and the added friend. This is because when each other's friends list gets updated, the online status indicator also needs to show the correct status. Other than that, we **emit** the **addedAsFriend** to the friend which will trigger a query invalidation.

```ts
socket.on("addFriend", async (friendId: string, userId: string, socketId: string, status: "online" | "away") => {

  const addedFriend = await redis.hmget(`user:${friendId}`, "socketId", "status")

  const friendSocketId = addedFriend[0]
  const friendStatus = addedFriend[1]

  // if the friend isn't logged in (or not online on our app)
  if (!friendSocketId) return

  io.to(socket.id).emit("getOnlineFriend", friendId, friendSocketId, friendStatus)
  io.to(friendSocketId).emit("getOnlineFriend", userId, socketId, status)
  io.to(friendSocketId).emit("addedAsFriend")
})
```

#### `emit("addedAsFriend")`
**Where**: Server

As stated above, this event is emitted to the added friend. The friend's friends list is invalidated.

```ts
io.to(friendSocketId).emit("addedAsFriend")
```

#### `on("addedAsFriend")`
**Where**: Client

When sent from the server, the client's friends list is invalidated.

```ts
socket.on("addedAsFriend", async () => {
  await queryClient.invalidateQueries({ queryKey: ["friend_list", userId] })
})
```

#### `emit("addedInChatroom")`
**Where**: Client

When a user creates a chat (with a friend), this event is emitted from the client. It's main purpose is to update the chat list of the people involved in the chat.

```ts
socket.emit("addedInChatroom", user?.id, friendIds, data.chatroomId, onlineFriends)
```

The important thing to note here is that he have to send the **onlineFriends** as it contains the socket ids of the friends. We will use these ids to emit an event to the friend's client to update their UI.

#### `on("addedInChatroom")`
**Where**: Server

We filter the socket ids so that it only includes those of the chatroom participants. We map over them and emit an **addedInChatroom** event to those friends.

```ts
friendSocketIds.forEach(socketId => {
  return io.to(socketId).emit("addedInChatroom")
})
```

**Where**: Client

When emitted from the server, we invalidate the chat list in the friend's client.

```ts
socket.on("addedInChatroom", async () => {
  await queryClient.invalidateQueries({ queryKey: ["chat_list", user?.id] })
})
```

#### `emit("connectToRoom")`
**Where**: Client

When a user navigates to a chatroom, this socket event is triggered from the client. It sends the **chatroomId** and the **user.id** to the server.

```ts
socket.emit("connectedToRoom", chatroomId, user.id)
```

#### `on("connectToRoom")`
**Where**: Server

The **connectToRoom** is very important as it serves important features in Chatty. First of all, it joins the current user to a socket room with the id of being the chatroom id. Another important feature is that it saves the "last seen" value in redis. This is essential as this value is used in the client's UI to indicate how many messages a user didn't see.

```ts
const timestamp = Date.now()
await socket.join(chatroomId);
await redis.set(`last_seen-${userId}-${chatroomId}`, timestamp)

io.to(chatroomId).emit("joined-chatroom")
```

#### `emit("joinedChatroom")`
**Where**: Server

This event is emitted from the server after a user successfully joins the chatroom socket room.

```ts
io.to(chatroomId).emit("joinedChatroom")
```

#### `on("joinedChatroom")`
**Where**: Client

When a user successfully connects to the chatroom socket room, 









