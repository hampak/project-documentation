# Table of Contents
1. [Project Overview](#project-overview)
2. [API Documentation](#api-documentation)
3. Features
4. Notable Bugs & Problems I encountered
5. Learning Experience

# Project Overview
Chatty is a chatting application where users can communicate with each other. The idea of real-time communication has always intrigued me and I was really interested in building a project like this. I learned a lot of technologies while building this project such as **redis** and **web sockets**.

I built this project using the tech stack / packages below:
```json
{
  "express",
  "mongoose",
  "socket.io",
  "jsonwebtoken",
  "redis",
  "google-auth-library",
  "cookie",
  "react",
  "@tanstack/react-query",
  "react-hook-form",
  "react-router-dom",
  "tailwind",
  "zod",
  "zustand"
}
```

I chose **ExpressJS** because I wanted to be more comfortable using it. For the main database, I used **MongoDB** and for data requiring a lot of read/writes, I used **redis(upstash)**.

One important thing to note here is that I didn't use an authentication service such as Clerk or Kinde. I wanted to learn **OAuth 2.0** so I didn't use any of those third-party authentication service providers.

In the frontend, I used **React**. For routing and navigation I used **react router dom**. For data fetching, I used **tanstack query**. For styling I used **tailwindcss**.

The server is deployed on **railway** and the client is hosted on **vercel**.

Through this project, I wanted to fortify my knowledge on key concepts of some of the most important technologies used around the world.

# API Documentation

### `/api/auth`
- [`api/auth/google`](#apiauthgoogle)
- [`api/auth/google/callback`](#apiauthgooglecallback)
- [`api/auth/github`](#apiauthgithub)
- [`api/auth/github/callback`](#apiauthgithubcallback)
- [`api/auth/logout`](#apiauthlogout)
- [`api/auth/check-auth`](#apiauthcheck-auth)

#### `/api/auth/google`
**Method**: GET

Api route that gets called when the user clicks on "Start with Google". When this api route gets called, it uses the **google-auth-library** package to create a **redirect url**.

```ts
const authUrl = oauth2Client.generateAuthUrl({
  access_type: "offline",
  scope: 'https://www.googleapis.com/auth/userinfo.profile  openid ',
  prompt: "consent"
})
```

The user is then redirected to the **authUrl** page. In this page, the user selects which Google account they will use to access Chatty.

This route also implements a check where it takes a look at the cookie in the user's web browser. When it retrieves a cookie named **user**, the route will check in the database to see if the decoded token (using JWT) is valid. If it is not valid (say, the user put invalid cookie data), they will get redirected to the **authUrl** page. If the decoded cookie value does turn out to be valid, the user will be redirected to the **/dashboard** page in the client rather than the **authURL** page.

```ts title="/api/auth/google"
const token = req.cookies.user

if (token) {
  try {
    const decoded = jwt.verify(token, JWT_SCRET!)
    if (typeof decoded !== "string" && decoded.user._id) {
      User.findById(decoded.user_id).then(user => {
        if (user) {
          return res.redirect(`${CLIENT_URL}/dashboard`)
        } else {
          // generate authURL and redirect user to the Google login page
        }
      })
    }
  } catch (error) {
    // if any error happens, generate authURL and redirect the user to the Google login page
  }
} else {
  // generate authURL and redirect the user to the Google login page
}
```

#### `/api/auth/google/callback`
**Method**: GET

After the user gets redirected to the Google account select page, and after the user chooses an account, this api route is called. In this api route, I implemented logic to retrieve the user's token which in turn can be used to access user information such as **sub** (An identifier for the user, unique among all Google accounts and never changed.), **name** and **picture**.

One of the most important logic in this api route is checking to see if the user already exists in our database. This is implemented by simply checking if a user with a **google_id** - which was provided by Google - already exists. If this is the case, carry on with the rest of the logic. If it's not the case (the user's first time accessing this application), save the user in our database.

The logged in user's data is stored as a cookie which is named **user** with a value generated by JWT.

```ts
const token = jwt.sign({
  user_id,
  name,
  picture
},
  JWT_SECRET!,
  { expiresIn: "60m" }
)

res.cookie("user", token, {
  httpOnly: true,
  maxAge: 60 * 60 * 1000,
  // other configurations
})

res.redirect(`${CLIENT_URL}/dashboard`)
```

#### `/api/auth/github`
**Method**: GET

This api route handles users who want to log in with their Github account. When the user clicks on "Start with Github", the client is directed to this route. Here, we retrieve the github redirect URL.

```ts
.get("/github", async (req, res) => {
  const redirectUrl = `https://github.com/login/oauth/authorize?client_id=${GITHUB_CLIENT_ID}&redirect_uri=http://localhost:8000/api/auth/github/callback&scope=user`

  res.redirect(redirectUrl)
})
```

#### `/api/auth/github/callback`
**Method**: GET

This route is for those redirected from the `/api/auth/github` route. It retrieves the access token using the **GITHUB_CLIENT_ID** and **GITHUB_CLIENT_SECRET**. From this, we can get the user's Github account information such as the **profile picture**, **name** and **id**. The **id** will be used as a unique identifier when we store the user in MongoDB database.

```ts
const { code } = req.query;

if (!code) {
  return res.status(400).send("No code provided")
}

try {
  const tokenResponse = await axios.post(
    "https://github.com/login/oauth/access_token",
    {
      client_id: GITHUB_CLIENT_ID,
      client_secret: GITHUB_CLIENT_SECRET,
      code
    },
    {
      headers: {
        accept: "application/json"
      }
    }
  )

  const accessToken = tokenResponse.data.access_token

  const userResponse = await axios.get("https://api.github.com/user", {
    headers: {
      Authorization: `Bearer ${accessToken}`
    }
  })

  const { avatar_url, name, id } = userResponse.data
  ...
  } catch ...
```

After this, the logic is pretty much the same with the `/api/auth/google/callback` route.

#### `/api/auth/logout`
**Method**: GET

This route logs the client out of the application. It clears the cookie (which holds the session token) from the user's browser and also deletes the session token from our redis database. The user is then navigated to the dashboard page.

```ts
.get("/logout", async (req, res) => {
    const token = await req.cookies.user
    const decoded = jwt.verify(token, JWT_SECRET!) as JwtPayload

    res.clearCookie("user")
    await redis.del(`sessionToken-${decoded.user_id}`)
    res.redirect(`${CLIENT_URL}`)
  })
```

#### `/api/auth/check-auth`
**Method**: GET

This route is used for **route protection** in our client. It first checks if a cookies of the name "user" exists. If it doesn't, send a **401** error which will redirect the user to the `/login` page.

If there is a token, run some checks to see if it also exists in the database. Send a **200** status if the user is authenticated. Send a **401** status if the user is not (which will send the user back to the login page.

This route is used [here]()

### `/api/user`
- [`/api/user`](#apiuser)

#### `/api/user`
**Method**: GET

This api route is used to retrieve the information of the currently logged in user. It checks the session token to see if it's valid. After that, the route queries the MongoDB database and retrieves the following information:

- id - the unique user id generated by MongoDB
- name - the name of the user (name set in Google / Github depending on registration method)
- picture - the profile image of the user
- online - the online status of the user (**This value isn't used as I'm retrieving the online status from Redis**)
- userTag - a unique identifier **used by the users** to add each other as friends

Just as a safety measure, if there's anything wrong with the token, the server sends a **401** error.

### `/api/friend`
- [`/api/friend`](#apifriend)
- [`/api/friend/add-friend`](#apifriendadd-friend)
- `/api/friend/delete-friend` **Not built yet**

#### `/api/friend`
**Method**: GET

This route fetches the friend(s) of the currently logged in user. It receives the **userId** from the client and queries the database. If there isn't a user with the id of **userId** found, return a **401** error.

If there is, query the user's friend(s) and their data

- _id - the unique user id generated by MongoDB
- name - name of the friend
- image - profile image of the friend
- userTag - userTag of the friend

This data is then stored in a array called **friends** which is then sent to the client.

```ts
const friendsList = await User.find({
  _id: { $in: user.friends }
}).select("_id name image userTag")

const friends = friendsList.map(friend => ({
  userId: friend._id.toString(),
  name: friend.name,
  image: friend.image,
  userTag: friend.userTag
}))
```

#### `/api/friend/add-friend`
**Method**: POST

This route adds a friend for the user. It receives the **friendUserTag** and **userId** from the client. The api first checks to see if the user is already friends with the current user. If they are already friends, send an error message to the client. Also, check to see if the user is trying to befriend him/herself (as this shouldn't be possible).

After these checks, add the friend's id to the list of the current user's friends in the database. Do it the same vice versa as the friend's friend list should also be updated.

We also update the friends list on redis. We do this so we can quickly read/write in our socket server.

After the friend has been successfully added, send back the following data to the client:

- friendUserTag - the userTag of the added friend
- friendName - the name of the added friend
- friendId - the id of the added friend
