# Table of Contents
1. [Project Overview](#project-overview)
2. [API Documentation](#api-documentation)
3. Features
4. Notable Bugs & Problems I encountered
5. Learning Experience

# Project Overview
Chatty is a chatting application where users can communicate with each other. The idea of real-time communication has always intrigued me and I was really interested in building a project like this. I learned a lot of technologies while building this project such as **redis** and **web sockets**.

I built this project using the tech stack / packages below:
```json
{
  "express",
  "mongoose",
  "socket.io",
  "jsonwebtoken",
  "redis",
  "google-auth-library",
  "cookie",
  "react",
  "@tanstack/react-query",
  "react-hook-form",
  "react-router-dom",
  "tailwind",
  "zod",
  "zustand"
}
```

I chose **ExpressJS** because I wanted to be more comfortable using it. For the main database, I used **MongoDB** and for data requiring a lot of read/writes, I used **redis(upstash)**.

One important thing to note here is that I didn't use an authentication service such as Clerk or Kinde. I wanted to learn **OAuth 2.0** so I didn't use any of those third-party authentication service providers.

In the frontend, I used **React**. For routing and navigation I used **react router dom**. For data fetching, I used **tanstack query**. For styling I used **tailwindcss**.

The server is deployed on **railway** and the client is hosted on **vercel**.

Through this project, I wanted to fortify my knowledge on key concepts of some of the most important technologies used around the world.

# API Documentation

### `/api/auth/google`
Api route that gets called when the user clicks on "Start with Google". When this api route gets called, it uses the **google-auth-library** package to create a **redirect url**.

```ts
const authUrl = oauth2Client.generateAuthUrl({
  access_type: "offline",
  scope: 'https://www.googleapis.com/auth/userinfo.profile  openid ',
  prompt: "consent"
})
```

The user is then redirected to the **authUrl** page. In this page, the user selects which Google account they will use to access Chatty.

This route also implements a check where it takes a look at the cookie in the user's web browser. When it retrieves a cookie named **user**, the route will check in the database to see if the decoded token (using JWT) is valid. If it is not valid (say, the user put invalid cookie data), they will get redirected to the **authUrl** page. If the decoded cookie value does turn out to be valid, the user will be redirected to the **/dashboard** page in the client rather than the **authURL** page.

```ts title="/api/auth/google"
const token = req.cookies.user

if (token) {
  try {
    const decoded = jwt.verify(token, JWT_SCRET!)
    if (typeof decoded !== "string" && decoded.user._id) {
      User.findById(decoded.user_id).then(user => {
        if (user) {
          return res.redirect(`${CLIENT_URL}/dashboard`)
        } else {
          // generate authURL and redirect user to the Google login page
        }
      })
    }
  } catch (error) {
    // if any error happens, generate authURL and redirect the user to the Google login page
  }
} else {
  // generate authURL and redirect the user to the Google login page
}
```

### `/api/auth/google/callback` 
After the user gets redirected to the Google account select page, and after the user chooses an account, this api route is called. In this api route, I implemented logic to retrieve the user's token which in turn can be used to access user information such as **sub** (An identifier for the user, unique among all Google accounts and never changed.), **name** and **picture**.

One of the most important logic in this api route is checking to see if the user already exists in our database. This is implemented by simply check if a user with a **google_id** of which was provided by Google already exists. If this is the case, carry on with the rest of the logic. If it's not the case (the user's first time accessing this application), save the user in our database.

The logged in user's data is stored as a cookie which is named **user** with a value generated by JWT.

```ts
const token = jwt.sign({
  user_id,
  name,
  picture
},
  JWT_SECRET!,
  { expiresIn: "30m" }
)

res.cookie("user", token, {
  httpOnly: true,
  maxAge: 60 * 60 * 1000,
  // other configurations
})

res.redirect(`${CLIENT_URL}/dashboard`)
```
